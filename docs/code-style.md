# Код-стайл

## Оглавление

1. [Рекомендация по улучшению качества кода](#рекомендация-по-улучшению-качества-кода)
2. [Комментарии к коду](#комментарии-к-коду)
3. [Рекомендации по использованию технологий](#рекомендации-по-использованию-технологий)

## Рекомендация по улучшению качества кода

Рекомендуется прогонять код через LLM-модель для выполнения дополнительной декомпозиции и форматирования, с целью повышения читаемости и поддерживаемости.

## Комментарии к коду

Комментарии допустимы **только** в следующих случаях:

- Объяснение **нетривиального решения**: когда реализация выбрана неочевидным образом, и требуется пояснение «почему так».
- Указание на **особенности поведения** системы, при изменении которых функциональность может стать нестабильной или непредсказуемой.

## Рекомендации по использованию технологий

### TypeScript

#### Правила наименования типов

При наименовании типов указывается **только название сущности**, к которой они относятся.
Примеры: `Product`, `MenuItem` и т.д.

Если тип является объектным и в своей структуре содержит другие объекты, в его названии дополнительно указывается свойство, которое он описывает.

**Пример:**

```ts
type ProductInfoWeight = {
  kilo: number;
};

type ProductInfo = {
  name: string;
  weight: ProductInfoWeight;
};

type Product = {
  info: ProductInfo;
};
```

Если название типа совпадает с названием компонента или другой сущности в файле, применяется **венгерская нотация** для обозначения типа.

**Пример:**

```ts
export { Product as TProduct } from "...";
```

#### Использование декларации `type`

Начиная с версии **TypeScript 5+**, в проекте запрещено использовать декларацию `interface` для описания новых типов данных.
Вместо неё следует применять декларацию `type`.

**Исключение:** разрешается использовать `interface` только в случаях, когда необходимо расширить интерфейс сторонней библиотеки, и при этом отсутствует возможность его экспорта из этой библиотеки. В таких ситуациях применяется механизм [Declaration Merging](https://www.typescriptlang.org/docs/handbook/declaration-merging.html).

#### Правила использования `enum`

В архитектуре любого проекта существует чёткое разделение, как минимум, на два типа кода: **наш** и **не наш** (внешний). Это разделение формирует базовые слои приложения.

`enum` в TypeScript является одной из немногих сущностей, обладающих **номинальной типизацией** — проверка типов выполняется не только по структуре, но и с учётом их происхождения. Это свойство позволяет эффективно отслеживать сущности, относящиеся к нашему коду.

**Правило:** `enum` допускается использовать **только** для описания сущностей, относящихся к **нашему** коду. Применение `enum` для внешних данных запрещено, чтобы не нарушать архитектурное представление и не смешивать слои.

#### Приведение значений к одному типу

Если переменная может принимать значения различных типов (не только `boolean`), необходимо явно привести их к одному типу. Это снижает вероятность ошибок, связанных с неявным преобразованием типов.

**Плохо:**

```ts
const shouldRenderErrorComponent = false || "абракадабра" || futureConfig;
```

**Хорошо:**

```ts
const shouldRenderErrorComponent =
  false || Boolean("абракадабра") || Boolean(futureConfig);
```

**Отлично:**

```ts
const shouldRenderErrorComponent = Boolean(
  false || "абракадабра" || futureConfig,
);
```

### React

### Работа с кодом

Одной из особенностей разработки на React является то, что в рамках одного модуля количество переменных может достигать больших значений. Все переменные должны иметь уникальные и осмысленные названия.

В проекте установлены следующие правила нейминга функций и констант:

1. **Деструктуризация** допускается **только** для значений из `props`. Доступ ко всем остальным свойствам объектов осуществляется через оператор точки (`.`).
2. **Нейминг констант и обработчиков событий** должен полностью совпадать с названием компонента или элемента JSX, к которому они относятся. Если одноимённых компонентов несколько, в название добавляется название компонента или элемента JSX и дополнительная характеристика, описывающая различие.

**Пример:**

```tsx
export const Example = () => {
  const [value, setValue] = useState("");

  const titleMainTag = "h1";
  const titleSubTag = "h2";

  const onChange = (value: TInput["value"]) => {
    setValue(value);
  };

  return (
    <Layout>
      <Title tag={titleMainTag} view="large">
        Заголовок
      </Title>
      <Title tag={titleSubTag} view="large">
        Подзаголовок
      </Title>
      <Input value={value} onChange={onChange} />
    </Layout>
  );
};
```

3. **Запрещается** размещать обработку событий или условия, содержащие два и более операторов, непосредственно в JSX. **Исключение**: стилизация с использованием библиотеки [`classNames`](https://www.npmjs.com/package/classnames).
4. Если код внутри тела компонента выполняет более одного действия (исключая обработчики событий), он обязан быть вынесен в отдельную функцию с описательным названием. Если таких функций несколько и они связаны между собой порядком выполнения или семантически, их необходимо объединить в отдельный класс.
5. Для повышения читаемости кода и предотвращения путаницы между реактивными (useState, useEffect и т.д.) и нереактивными сущностями, рекомендуется соблюдать следующий порядок размещения элементов внутри React-компонентов:

```bash
1. Хуки состояния. Использование `useState`, `useReducer` и других хуков для управления локальным состоянием.
2. Константы — локальные неизменяемые значения, переменные окружения, конфигурации и т.п.
3. Функции, используемые внутри JSX: колбэки, обработчики пользовательского ввода и бизнес-логика.
4. Хуки эффекты. Хуки с побочными эффектами и мемоизацией: `useEffect`, `useMemo`, `useCallback` и др.
5. `return` — JSX-структура компонента.
```

**Пример:**

```tsx
const Example = () => {
  // 1. Хуки состояния
  const [value, setValue] = useState("");

  // 2. Константы
  const shouldRender = true;

  // 3. Обработчики и хелперы
  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
    setValue(e.target.value);
  };

  // 4. Эффекты
  useEffect(() => {
    console.log(value);
  }, [value]);

  // 5. JSX
  return (
    <Fragment>
      {shouldRender && <input value={value} onChange={handleChange} />}
    </Fragment>
  );
};
```

6. Все константы, определяющие условия рендера, **должны** начинаться с префикса `shouldRender`.

**Пример:**

```ts
const shouldRenderErrorComponent = Boolean(error);
const shouldRenderEmptyState = items.length === 0;
```

7. Упрощение хука `useEffect`

Если тело `useEffect` превышает 10 строк, его необходимо **вынести в именованную функцию-обёртку** с понятным назначением. Это улучшает читаемость и повторную используемость кода.

**Плохо:**

```tsx
useEffect(() => {
  const urlParams = new URLSearchParams(window.location.search);
  const urlParamsClientCus = urlParams.get(UrlQueryName.ClientCus);
  const urlParamsScreen = urlParams.get(UrlQueryName.Screen);
  const urlParamsPid = urlParams.get(UrlQueryName.Pid);

  const actualClientCus = urlParamsClientCus ?? DEFAULT_CLIENT_CUS;
  const actualScreen = urlParamsScreen ?? DEFAULT_SCREEN;
  const actualPid = urlParamsPid ?? DEFAULT_PID;

  setClientCus(actualClientCus);
  setScreen(actualScreen);
  setPid(actualPid);
  setIsUrlParamsTaken(true);
}, []);
```

**Отлично:**

```tsx
useEffect(() => {
  function getQueryFilters() {
    const urlParams = new URLSearchParams(window.location.search);
    const urlParamsClientCus = urlParams.get(UrlQueryName.ClientCus);
    const urlParamsScreen = urlParams.get(UrlQueryName.Screen);
    const urlParamsPid = urlParams.get(UrlQueryName.Pid);

    const actualClientCus = urlParamsClientCus ?? DEFAULT_CLIENT_CUS;
    const actualScreen = urlParamsScreen ?? DEFAULT_SCREEN;
    const actualPid = urlParamsPid ?? DEFAULT_PID;

    setClientCus(actualClientCus);
    setScreen(actualScreen);
    setPid(actualPid);
    setIsUrlParamsTaken(true);
  }

  getQueryFilters();
}, []);
```

Вот как можно оформить этот пункт в стиле технической документации:

---

8. Использование `React.memo`, `useMemo` и `useCallback` **крайне не рекомендуется** из-за неопределённого поведения этих API и возможного их удаления из публичного API в React 19+.
9. В теле компонента или в JSX **запрещено выполнять операции с побочными эффектами** (например, сетевые запросы, изменение глобального состояния, логирование и т.п.). Такие операции должны выполняться только в хуках `useEffect` или в соответствующих обработчиках событий.
10. Все компоненты и состояния, создаваемые с помощью хуков, должны быть **строго типизированы**. Использование `any` и неявных типов недопустимо.
11. Условия в операторе `if` не должны содержать более одной константы. Если в условии участвуют две и более константы, необходимо создать дополнительную переменную с осмысленным названием и использовать её в условии.

**Плохо:**

```ts
if (isUserLoggedIn && hasUserPermissions) {
  // логика
}
```

**Хорошо:**

```ts
const canAccessPage = isUserLoggedIn && hasUserPermissions;

if (canAccessPage) {
  // логика
}
```
